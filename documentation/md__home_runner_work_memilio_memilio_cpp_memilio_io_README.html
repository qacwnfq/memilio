<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEmilio: MEmilio C++ IO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEmilio
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">MEmilio C++ IO </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This directory contains utilities for reading and writing data from and to files in different formats. The main part is a serialization framework that can be used to define the structure of data without using a specific file format. There are implementations of the framework for different formats. The framework is described in detail below, also see the <a href="../../examples/serialize.cpp">serialization example</a>.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
The Serialization framework</h1>
<h1><a class="anchor" id="autotoc_md15"></a>
Main functions and types</h1>
<ul>
<li>functions serialize and deserialize: Main entry points to the framework to write and read values, respectively. The functions expect an IOContext (see Concepts below) that stores the serialized data. (De-)serialization can be customized by providing a (de-)serialize_internal overload or a (de-)serialize member function for the type. See the section "Implementing
     serialization for a new type" or the documentation for <code>serialize</code> and <code>deserialize</code>.</li>
<li>IOStatus and IOResult: Used for error handling, see section "Error Handling" below.</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Concepts</h1>
<ol type="1">
<li>IOContext Stores data that describes serialized objects of any type in some unspecified format and provides structured access to the data for deserialization. Implementations of this concept may store the data in any format they want including binary. The data may also be written directly to disk. The context also keeps track of errors. An IOContext object <code>io</code> allows the following operations: <pre class="fragment">- `io.create_object("Type")`:
    Returns an IOObject for the type called `"Type"`. The IOObject (see below) allows adding data that describes
    the object to be serialized. The function must return something that can be assigned to a local
    variable, e.g., a temporary or copyable function. IOObject may store references to the context internally,
    so the lifetime of the local IOObject may not exceed the lifetime of the IOContext that created it.
- `io.expect_object("Type")`:
    Returns an IOObject for the type called `"Type"`.
    The IOObject (see below) provides access to the data needed for deserialization.
- `io.flags()`:
    Returns the flags that determine the behavior of serialization; see IOFlags.
- `io.error()`:
    Returns an IOStatus object to check if there were any errors during serialization.
    Usually it is not necessary to check this manually but can be used to report the error faster and
    avoid expensive operations that would be wasted anyway.
- `io.set_error(s)` with some IOStatus object:
    Stores an error that was generated outside of the IOContext, e.g., if a value that was deserialized
    is outside an allowed range.
</pre></li>
</ol>
<ol type="1">
<li>IOObject Gives structured access to serialized data. During serialization, data can be added with <code>add_...</code> operations. During deserialization, data can be retrieved with <code>expect_...</code> operations. Data must be retrieved in the same order as it was added since, e.g., binary format does not allow lookup by key. The following operations are supported for an IOObject <code>obj</code>: <pre class="fragment"> - `obj.add_element("Name", t)`:
      Stores an object `t` in the IOObject under the key "Name". If `t` is of basic type (i.e., int, string), IOObject
      is expected to handle it directly. Otherwise, the object uses `mio::serialize` to get the data for `t`.
 - `obj.add_list("Name", b, e)`:
      Stores the elements in the range represented by iterators `b` and `e` under the key "Name". The individual elements are not named.
      The elements are either handled directly by the IOObject or using `mio::serialize` just like `add_element`.
 - `obj.add_optional("Name", p)`:
      Stores the element pointed to by pointer `p` under the key "Name". The pointer may be null. Otherwise identical to add_element.
 - `obj.expect_element("Name", Tag&lt;T&gt;{})`:
      If an object of type T can be found under the key "Name" and can be deserialized, returns the object. Otherwise returns
      an error. Analogously to serialization, the IOObject is expected to handle basic types directly and use `mio::deserialize`
      otherwise.
 - `obj.expect_list("Name", Tag&lt;T&gt;{})`:
      If a list of objects of type T can be found under the key "Name" and can be deserialized, returns a range that can be
      iterated over. Otherwise returns an error.
 - `obj.expect_optional("Name", Tag&lt;T&gt;{})`:
      Returns ```boost::optional&lt;T&gt;``` if an optional value of type T can be found under the key "Name". The optional may contain a
      value or it may be empty. Otherwise returns an error. Note that for some formats a wrong key is indistinguishable from
      an empty optional, so make sure to provide the correct key.
</pre> </li>
</ol>
<h1><a class="anchor" id="autotoc_md17"></a>
Error handling</h1>
<p>Errors are handled by returning error codes. The type IOStatus contains an error code and an optional string with additional information. The type IOResult contains either a value or an IOStatus that describes an error. Operations that can fail return an <code>IOResult&lt;T&gt;</code> where T is the type of the value that is produced by the operation if it is succesful. Except where necessary because of dependencies, the framework does not throw nor catch any exceptions. IOContext and IOObject implementations are expected to store errors. During serialization, <code>add_...</code> operations fail without returning errors, but the error is stored in the IOObject and subsequent calls are usually no-ops. During deserialization, the values produced must usually be used or inspected, so <code>expect_...</code> operations return an IOResult. The <code>apply</code> utility function provides a simple way to inspect the result of multiple <code>expect_...</code> operations and use the values if all are succesful. See the documentation of <code>IOStatus</code>, <code>IOResult</code> and <code>apply</code> below for more details.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Adding a new data type to be serialized</h1>
<p>Serialization of a new type T can be customized by providing <em>either</em> member functions <code>serialize</code> and <code>deserialize</code> <em>or</em> free functions <code>serialize_internal</code> and <code>deserialize_internal</code>.</p>
<p>The <code>void serialize(IOContext&amp; io)</code> member function takes an IO context and uses <code>create_object</code> and <code>add_...</code> operations to add data. The static <code>IOResult&lt;T&gt; deserialize(IOContext&amp; io)</code> member function takes an IO context and uses <code>expect_...</code> operations to retrieve the data. The <code>apply</code> utility function can be used to inspect the result of the <code>expect_...</code> operations and construct the object of type T. E.g.:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> IOContext&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba">serialize</a>(IOContext&amp; io) {</div>
<div class="line">    <span class="keyword">auto</span> obj = io.create_object(<span class="stringliteral">&quot;Foo&quot;</span>);</div>
<div class="line">    obj.add_element(<span class="stringliteral">&quot;i&quot;</span>, i);</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> IOContext&gt;</div>
<div class="line">  <span class="keyword">static</span> IOResult&lt;Foo&gt; <a class="code" href="namespacemio.html#a1eecf99ef3a231d628f968aeb2136865">deserialize</a>(IOContext&amp; io) {</div>
<div class="line">    <span class="keyword">auto</span> obj = io.expect_object(<span class="stringliteral">&quot;Foo&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> i_result = obj.expect_element(<span class="stringliteral">&quot;i&quot;</span>, <a class="code" href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">mio::Tag&lt;int&gt;</a>{});</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacemio.html#a3cd34c233549e8b0e086c67fd82809d3">mio::apply</a>(io, [](<span class="keyword">auto</span>&amp;&amp; i) { <span class="keywordflow">return</span> Foo{i}; }, i_result);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="anamespacemio_html_a1eecf99ef3a231d628f968aeb2136865"><div class="ttname"><a href="namespacemio.html#a1eecf99ef3a231d628f968aeb2136865">mio::deserialize</a></div><div class="ttdeci">IOResult&lt; T &gt; deserialize(IOContext &amp;io, Tag&lt; T &gt; tag)</div><div class="ttdoc">Restores an object from the data stored in an IO context.</div><div class="ttdef"><b>Definition:</b> io.h:809</div></div>
<div class="ttc" id="anamespacemio_html_a27a24b9e6cb629e04e9613446f07d6ba"><div class="ttname"><a href="namespacemio.html#a27a24b9e6cb629e04e9613446f07d6ba">mio::serialize</a></div><div class="ttdeci">void serialize(IOContext &amp;io, const T &amp;t)</div><div class="ttdoc">Save data that describes an object in a format determined by the given context.</div><div class="ttdef"><b>Definition:</b> io.h:785</div></div>
<div class="ttc" id="anamespacemio_html_a2f858e287c3935240954cf75cf53cfeb"><div class="ttname"><a href="namespacemio.html#a2f858e287c3935240954cf75cf53cfeb">mio::Tag</a></div><div class="ttdeci">boost::outcome_v2::in_place_type_t&lt; T &gt; Tag</div><div class="ttdoc">Type that is used for overload resolution.</div><div class="ttdef"><b>Definition:</b> io.h:400</div></div>
<div class="ttc" id="anamespacemio_html_a3cd34c233549e8b0e086c67fd82809d3"><div class="ttname"><a href="namespacemio.html#a3cd34c233549e8b0e086c67fd82809d3">mio::apply</a></div><div class="ttdeci">details::ApplyResultT&lt; F, T... &gt; apply(IOContext &amp;io, F f, const IOResult&lt; T &gt; &amp;... rs)</div><div class="ttdoc">Evaluate a function with zero or more unpacked IOResults as arguments.</div><div class="ttdef"><b>Definition:</b> io.h:472</div></div>
</div><!-- fragment --><p>The free functions <code>serialize_internal</code> and <code>deserialize_internal</code> must be found with argument dependent lookup (ADL). They can be used if no member function should or can be added to the type. See the code below for examples where this was done for, e.g., Eigen3 matrices and STL containers.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Adding a new format</h1>
<p>Implement concepts IOContext and IOObject that provide the operations listed above. Your implemenation should handle all built in types as well as std::string. It may handle other types (e.g., STL containers) as well if it can do so more efficiently than the provided general free functions.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Other IO modules</h1>
<ul>
<li>HDF5 support classes for C++</li>
<li>Reading of mobility matrix files</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
The command line interface</h1>
<p>We provide a function <code>mio::command_line_interface</code> in the header <code><a class="el" href="cli_8h.html">memilio/io/cli.h</a></code>, that can be used to write to or read from a parameter set. It can take parameters from command line arguments (i.e. the content of <code>argv</code> in the main function), and assign them to or get them from a <code><a class="el" href="classmio_1_1ParameterSet.html" title="a set of parameters defined at compile time">mio::ParameterSet</a></code>. A small example can be seen in <code>cpp/examples/cli.cpp</code>.</p>
<p>The command line interface (CLI) provides some non-parameter options listed below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name (Alias) <div style="width:150px"></div>   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--help</code> (<code>-h</code>)   </td><td class="markdownTableBodyNone">Shows the basic usage of the CLI, and lists each parameter by name, as well as any alias and description. Takes priority before all other options and exits the programm.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--print_option</code>   </td><td class="markdownTableBodyNone">Can be used with a (space separated) list of parameter names or aliases (without dashes) to print the current values of each parameter to the terminal. This shows the correct json format used by the parameters. Exits after use.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--read_from_json</code>   </td><td class="markdownTableBodyNone">Allows reading parameters from a file instead of the command line. Both parameter names and aliases can be used, for example: <br  />
<code>{"&lt;ParameterName&gt;" : &lt;value&gt;, "&lt;ParameterAlias&gt;" : &lt;value&gt; }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--write_to_json</code>   </td><td class="markdownTableBodyNone">Writes <em>all</em> parameters with their current values to a specified file.   </td></tr>
</table>
<p>In general, an option is defined as a string, which consists either of two dashes followed by a name (e.g. &ndash;help), or a single dash followed by an alias (e.g. -h). Apart from the built-in options, the names each refer to a parameter that can be set.</p>
<p>To set the value of a parameter from the command line, first type the corresponding parameter option (see &ndash;help), followed by the value that should be assigned (reference &ndash;print_option). Values are given as a Json value corresponding to the Type of the parameter. Note that some characters may need to be escaped or quoted. For example, the Json string <code>"some string"</code> must be entered as <code>\"some string\\"</code> or &lsquo;&rsquo;"some string"'`.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Working with the History object</h1>
<p>The History object provides a way to save data throughout the simulation process. It offers an interface where users can define the data to be saved from a given object using Loggers and the method of saving it using Writers. Afterward, the user can access this data from the History object and manipulate it. For a basic Logger use case, refer to <a href="../../examples/history.cpp">this example</a>. For an example demonstrating using a Logger in the ABM, refer to <a href="../../examples/abm_history_example.cpp">this example</a>.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Loggers</h2>
<p>The <code>Logger</code> struct is a tool for logging data from a given object. Each user-implemented Logger must have a <code>Type</code> and implement two functions: <code>Type log(const T&amp;)</code> and <code>bool should_log(const T&amp;)</code>. The input <code>T</code> for these functions is the same as the one given to the <code>History</code> member-function <code>History::log</code>, e.g. <code>World&amp;</code> in the ABM.</p>
<ul>
<li><code>Type</code>: Return Type of <code>log</code>.</li>
<li><code>log</code>: This function determines which data from the input <code>T</code> is saved. It must have the same return Type <code>Type</code> as the Loggers Type <code>Type</code>.</li>
<li><code>should_log</code>: This function must return a boolean to determine if data should be logged and can use the input <code>T</code> for this, e.g. if <code>T</code> fullfills some criteria.</li>
</ul>
<p>Users can derive their Loggers from <code>LogOnce</code> or <code>LogAlways</code> to use a predefined <code>should_log</code> function. <code>LogOnce</code> logs only at the first call of <code><a class="el" href="namespacemio.html#a7a8e658f565465ae076eab415d976e1b">Logger::log()</a></code>, while <code>LogAlways</code> logs every time <code>log</code> is called. All implemented Loggers must be default constructible/destructible. For user-defined examples in the ABM, refer to <a href="../../models/abm/common_abm_loggers.h">this file</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>LoggerExample{ <span class="comment">/* :LogOnce/LogAlways if one wants to derive the should log from these. */</span></div>
<div class="line">    <span class="keyword">using</span> Type = <span class="comment">/* type of the record */</span>;</div>
<div class="line">    <span class="comment">/* Below, T must be replaced by the type T from History::log(t). */</span></div>
<div class="line">    Type <a class="code" href="namespacemio.html#a7a8e658f565465ae076eab415d976e1b">log</a>(<span class="keyword">const</span> T&amp; t) </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="comment">/* something of type Type */</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> should_log(<span class="keyword">const</span> T&amp; t) </div>
<div class="line">    {</div>
<div class="line">          <span class="comment">/* Determine wether log and add_record should be called by History::log(t). */</span></div>
<div class="line">          <span class="keywordflow">return</span> <span class="comment">/* true or false */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="anamespacemio_html_a7a8e658f565465ae076eab415d976e1b"><div class="ttname"><a href="namespacemio.html#a7a8e658f565465ae076eab415d976e1b">mio::log</a></div><div class="ttdeci">void log(LogLevel level, spdlog::string_view_t fmt, const Args &amp;... args)</div><div class="ttdef"><b>Definition:</b> logging.h:122</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
Writers</h2>
<p>The <code>Writer</code> struct defines how to store the logged data from one or more implemented <code>Loggers</code>. Each user-implemented <code>Writer</code> must have a <code>Data</code> Type and implement the <code>template &lt;class Logger&gt; static void add_record(const typename Logger::Type&amp; t, Data&amp; data)</code> function.</p>
<ul>
<li><code>Data</code>: This is some kind of container that stores the data returned by the Loggers. For example, this can be a TimeSeries or depend on the Loggers (like <code>std::tuple&lt;std::vector&lt;Logger::Type&gt;...&gt;</code>).</li>
<li><code>add_record</code>. This manipulates the passed Data member of the <code>History</code> class to store the value <code>t</code> returned by the Loggers. It is used whenever <code>History::log</code> is called and <code>Logger::should_log</code> is true.</li>
</ul>
<p>A predefined universal <code>Writer</code> <code>DataWriterToMemory</code> is already implemented in <a href="history.h">history.h</a>. This stores the data from the loggers in a tuple of vectors every time the Logger is called. Another <code>Writer</code> <code>TimeSeriesWriter</code> can be found in <a href="../../models/abm/common_abm_loggers.h">this file</a>, which saves data in a Timeseries. The according Logger has to have a suitable return type.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Loggers&gt;</div>
<div class="line"><span class="keyword">struct </span>DataWriterExample {</div>
<div class="line">    <span class="keyword">using</span> Data = <span class="comment">/* Container for the stored data of the Loggers */</span>;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Logger&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> add_record(<span class="keyword">const</span> <span class="keyword">typename</span> Logger::Type&amp; t, Data&amp; data)</div>
<div class="line">    {</div>
<div class="line">          <span class="comment">/* Manipulation of data to store the value t returned by the Loggers */</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
History</h2>
<p>The <code>History</code> class manages the Writers and Loggers and provides an interface to log data. It is templated on one <code>Writer</code> and several suitable and unique <code>Loggers</code>. To use the Writer to log something, the <code>History</code> provides the function <code>void log(const T&amp; t)</code> to call the <code>add_record</code> function of the <code>Writer</code> if the Logger function <code>should_log</code> returns true.</p>
<p>To access the data from the <code>History</code> class after logging, we provide the function <code>get_log</code> to access all records. For this, the lifetime of the <code>History</code> has to be as long as one wants to have access to the data, e.g. a history should not be constructed in the function it is called in when data is needed later.</p>
<p>To access data from a specific Logger, one can use <code>std::get&lt;x&gt;</code> where x is the position of the Logger in the template argument list of the <code>History</code> object. Refer to <a href="../../examples/history.cpp">this example</a> for a simple implementation of a history object and <a href="../../simulation/abm.cpp">this full ABM example</a> for a more advanced use case of the History object with several History objects in use.</p>
<p>As mentioned, if multiple Writers have to be used simultaneously, a separate History object is needed for each Writer. For a use case of this, refer to <a href="../../models/abm/simulation.cpp">the ABM Simulation advance function.</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
