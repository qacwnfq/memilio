<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MEmilio: /home/runner/work/memilio/memilio/cpp/memilio/utils/random_number_generator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MEmilio
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_df511e5bd85cec96854b39d5e1c27aa8.html">cpp</a></li><li class="navelem"><a class="el" href="dir_c21b77d896d8fb76ff5e46df13fe67f8.html">memilio</a></li><li class="navelem"><a class="el" href="dir_4ec964ee642de24b5606a410aeddc4e0.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">random_number_generator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="compiler__diagnostics_8h_source.html">memilio/utils/compiler_diagnostics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="logging_8h_source.html">memilio/utils/logging.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="miompi_8h_source.html">memilio/utils/miompi.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="span_8h_source.html">memilio/utils/span.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="type__safe_8h_source.html">memilio/utils/type_safe.h</a>&quot;</code><br />
<code>#include &quot;Random123/array.h&quot;</code><br />
<code>#include &quot;Random123/threefry.h&quot;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="random__number__generator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abb688b1bca227842d634ac4ef9dbfe3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="random__number__generator_8h.html#abb688b1bca227842d634ac4ef9dbfe3f">MSVC_WARNING_DISABLE_PUSH</a> (4127) <a class="el" href="compiler__diagnostics_8h.html#adbe015fd400c68971ee59ab01d441cb2">GCC_CLANG_DIAGNOSTIC</a>(ignored &quot;-Wexpansion-to-defined&quot;) namespace mio</td></tr>
<tr class="separator:abb688b1bca227842d634ac4ef9dbfe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abb688b1bca227842d634ac4ef9dbfe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb688b1bca227842d634ac4ef9dbfe3f">&#9670;&nbsp;</a></span>MSVC_WARNING_DISABLE_PUSH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MSVC_WARNING_DISABLE_PUSH </td>
          <td>(</td>
          <td class="paramtype">4127&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Base class for counter based random number generator.</p>
<p>All (pseudo) random number generators (RNG) consist of some state, a function <code>state = advance(state)</code>, and a function <code>sample = generate(state)</code>. They produce a sequence of random samples by advancing the state and from the new state generate the actual sample.</p>
<p>example in pseudo code: state = initial_state(seed) sample1 = generate(state) state = advance(state) sample2 = generate(state) ...</p>
<p>In most normal RNGs like mersenne twister the advance function needs to be complicated in order to perform the necessary mixing of bits. The state needs to be relatively large to contain sufficient numbers of random bits. The generate function on the other hand is very simple, often just returning the state (whole or in parts) without further computation.</p>
<p>In counter based generators (cRNG), the state and advance function are very simple and all the mixing of bits is in the generate function. The state is split into a key and a counter. The generate function is an encryption or hash function. Like a hash function, it produces a pseudo-random value from the input. The key is used by the generate function the same way as an encryption key. The key is randomly seeded in the beginning so that a different sequence of samples is generated on each run. Then the key doesn't change anymore. The advance function only increments the counter. The generate function produces completely different output even for sequential numbers.</p>
<p>Because their state is simple, cRNG are well suited for parallel applications. To create n independent subsequences from a total sequence of N samples you only need to create n counters, where counter i starts at i * (N / n). Normal RNGs need special algorithms to efficiently generate subsequences, if it is possible at all. The counter is of minimal size, it only needs to be big enough to fit the number of samples generated. Often the subsequence index i is already available in some other form, e.g., the thread index or the agent index in an agent based model, so only a small amount of extra storage is needed for the subsequence counter. The key is shared between all subsequences. Modern CPU architectures also are very efficient at executing the hash and encryption functions that are used as the generate function, increasing performance of the generator.</p>
<p>The length of the total sequence and the subsequences and the number of subsequences can be adjusted as needed by assigning different numbers of bits to the key, the subsequence index and the subsequence counter. The counter only needs to store the number of samples generated. A counter of c bits supports a sequence of 2^c samples or 2^n subsequences of 2^(c - n) samples, in which case you can split the counter into a subsequence index of n bits and a subsequence counter of (c - n) bits where each of the subsequence counters starts at 0. Generating a samples of k bits requires a key of at least k bits for sufficient randomness. Example:</p><ul>
<li>A 64 bit counter (uint64_t) and a 64 bit key produce 2^64 samples each with 64 bits. You need to store one counter and one key.</li>
<li>A subsequence index of 32 bits (uint32_t), subsequence counter with 32 bits and a 64 bit key produce 2^32 subsequences of 2^32 samples each with 64 bits per sample. You need to store 2^32 subsequence indices, 2^32 subsequence counters and one key, but the counters are completely independent and thread safe. The subsequence index and corresponding subsequence counter can also be stored together in one 64bit counter, e.g., the subsequence index is the high bits and subsequence counter is the low bits, see <code>rng_totalsequence_index()</code>.</li>
</ul>
<p>Also see <a href="https://github.com/DEShawResearch/random123">https://github.com/DEShawResearch/random123</a> for more information on cRNGs and the specific cRNG we use.</p>
<p>Classes deriving from this base class need to supply the key and counter by implementing the functions</p><ul>
<li>result_type get_key() const</li>
<li>result_type get_counter() const</li>
<li>void increment_counter()</li>
</ul>
<p>This class satisfies the standard UniformRandomBitGenerator concept.</p>
<p>Minimum value generated by this generator. Counterbased generators allow the whole range supported by the result_type.</p>
<p>Maximum value generated by this generator. Counterbased generators allow the whole range supported by the result_type.</p>
<p>Generate the next value in the random sequence. Key and counter are supplied by the Derived class by implementing the functions get_key(), get_counter(), and increment_counter().</p>
<p>Convert a Random123 array type (rng counters and keys) to uint64_t.</p>
<p>Convert a uint64_t to a Random123 array type (rng counters and keys).</p>
<p>A key type for counter based random number generators. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">an</td><td>unsigned integer type that determines the size of the key, i.e., the number of different sequences.</td></tr>
  </table>
  </dd>
</dl>
<p>A counter type for counter based random number generators. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">an</td><td>unsigned integer type that determines the size of the counter, i.e., the length of the random sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>Seed a counter based random number generator key. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>type that satisfies standard SeedSeq. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed_seq</td><td>A seed sequence, e.g. initialized using std::random_device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A seeded key.</dd></dl>
<p>Get the counter in the total sequence for a counter in a given subsequence. A total sequence counter of C bits supports 2^N subsequences of 2^(C - N) samples. Then the counter can be split into a subsequence index of N bits and a subsequence counter of S = (C - N) bits. The length of the subsequences is determined by the type of the subsequence counter and the requested total sequence counter. The subsequence index does not need to be exactly N bits, it can be larger. E.g., a subsequence counter of 16 bits and a subsequence index of 64 bits can be used for a combined counter of 64 bits since there is not 48 bit type. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UIntC</td><td>The counter type of the total sequence with C bits. </td></tr>
    <tr><td class="paramname">UIntN</td><td>An unsigned integer type with at least N bits for the subsequence index. </td></tr>
    <tr><td class="paramname">CounterS</td><td>A counter type with S = (C - N) bits for the subsequence counter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsequence_idx</td><td>The index of the subsequence. Must be less than 2^N. </td></tr>
    <tr><td class="paramname">counter</td><td>The counter in the subsequence. </td></tr>
    <tr><td class="paramname">return</td><td>The counter in the total sequence.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the subsequence counter from the total sequence counter. A total sequence counter of C bits supports 2^N subsequences of 2^(C - N) samples. Then the counter can be split into a subsequence index of N bits and a subsequence counter of S = (C - N) bits. The length of the subsequences is determined by the type of the subsequence counter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UIntS</td><td>An unsigned integer type of S bits for the subsequence counter. </td></tr>
    <tr><td class="paramname">CounterC</td><td>A counter type of C bits, where C &gt; S. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>The total sequence counter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The counter in the subsequence.</dd></dl>
<p>General purpose counter based random number generator. Stores its own key and counter. </p><dl class="section see"><dt>See also</dt><dd>RandomNumberGeneratorBase.</dd></dl>
<p>Set the seeds in all MPI processes the same as in the root.</p>
<p>get a random number generator that is static and local to this thread. </p><dl class="section return"><dt>Returns</dt><dd>a RandomNumberGenerator that is static and local to this thread. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not to be used anymore, only used by ParameterDistribution.</dd></dl>
<p>Log the seeds used by the RandomNumberGenerator at the specified LogLevel.</p>
<p>Log the seeds used by the RandomNumberGenerator from <a class="el" href="namespacemio.html#ac3f63f570d35c1f585afa4fb36e62078">thread_local_rng()</a> at the specified LogLevel.</p>
<p>adapter for a random number distribution. Provides a static thread local instance of the distribution and a replacable core generator function (e.g. for mocks during testing). The parameters of the distribution are passed when the random number is generated instead of when the object is constructed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DistT</td><td>a type that models the standard RandomNumberDistribution concept</td></tr>
  </table>
  </dd>
</dl>
<p>The type returned by the distribution.</p>
<p>The type that contains the parameters of the distribution. The template parameter must be constructible from this type.</p>
<p>get a static thread local instance of the contained Distribution class. Calls DistributionAdapter::get_instance().</p>
<p>The function that generates a random value from the distribution with the specified parameters.</p>
<p>the default generator function invokes an instance of the template parameter with a static thread local RNG engine. Constructors are private, use get_instance to get the current version.</p>
<p>get a random sample from the distribution. accepts the same arguments as the constructors of the template parameter type. example: std::uniform_int_distribution is constructed from two integers, so DistributionAdapter&lt;std::uniform_int_distribution&gt;::operator() accepts two integers as well.</p>
<p>get the generator function.</p>
<p>set the generator function.</p>
<p>get a static instance of this class. Instance is default constructed on the first call. The generator function of this instance can be replaced for mocking during tests.</p>
<p>select a random integer in [0, n) with weights [w_0, ..., w_(n-1)] the probability to pick i is w_i/S where S is the sum of all weights. Similar to std::discrete_distribution but does not allocate, instead expects a Span of weights. Models the standard RandomNumberDistribution concept.</p>
<p>the type returned by the distribution.</p>
<p>stores the parameters of the distribution (i.e. the weights).</p>
<p>default distribution has no weights. always returns 0.</p>
<p>distribution with specified weights.</p>
<p>distribution with specified params.</p>
<p>reset internal state. does nothing, but required by the concept.</p>
<p>get the parameters of the distribution.</p>
<p>set the parameters of the distribution.</p>
<p>get the weights.</p>
<p>draw a random number from the distribution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>object of a type that that models UniformRandomBitGenerator concept.</td></tr>
  </table>
  </dd>
</dl>
<p>draw a random number from the distribution with the specified parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>object of a type that that models UniformRandomBitGenerator concept. </td></tr>
    <tr><td class="paramname">p</td><td>parameters of the dstribution.</td></tr>
  </table>
  </dd>
</dl>
<p>adapted discrete distribution </p><dl class="section see"><dt>See also</dt><dd>DistributionAdapter</dd></dl>
<p>adapted std::exponential_distribution. </p><dl class="section see"><dt>See also</dt><dd>DistributionAdapter</dd></dl>
<p>adapted std::uniform_int_distribution. </p><dl class="section see"><dt>See also</dt><dd>DistributionAdapter</dd></dl>
<p>adapted uniform_real_distribution. </p><dl class="section see"><dt>See also</dt><dd>DistributionAdapter</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
